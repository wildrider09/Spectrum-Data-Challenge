# -*- coding: utf-8 -*-
"""India 3G and 5G

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SnAzlVrZ9jiOnGQ4otsmYnaBwtTAglNS

# Imports
"""

!pip3 install catboost
!pip install shap
!pip install xlrd

import catboost as cb
import numpy as np
import pandas as pd
import seaborn as sns
import shap
#import load_boston
from matplotlib import pyplot as pltfrom
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score
from sklearn.inspection import permutation_importance
from sklearn import datasets

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import transforms
import seaborn as sns

df = pd.read_excel ('Spectrum Database_March 2021.xlsx')

"""# Dataset

"""

df = df[(df.countryName == 'India')]
#df = df[df.awardName == '3G Auction']
df

print(df['awardName'].unique())
print(df.groupby('awardName').count())

df_3G = df[df.awardName == '3G auction']
df_3G

df_4G1 = df[df.awardName == 'India 800MHz']
df_4G2 = df[df.awardName == 'India 800MHz, 900MHz, 1800MHz and 2100MHz']
df_4G3 = df[df.awardName == 'India 900MHz & 1800MHz']
frame = [df_4G1, df_4G2, df_4G3]
df_4G = pd.concat(frame)
df_4G

df_2G = df[df.awardName == 'India 2G resale of quashed licences 1800MHz']
df_2G

payment = pd.read_excel ('Spectrum Payments_March 2021.xlsx') 
payment

"""# India 3G

"""

merged = pd.merge(df_3G, payment, on='lotId', how='inner')
merged

merged['awardName'].unique()

from matplotlib import pyplot as plt
plt.figure(figsize=(15,5))
# X axis : lotID
# Y axis : amount
plt.scatter(merged['lotId'], merged['amount'])

for i, winner in enumerate(merged['winner']):
  plt.annotate(winner, (merged['lotId'][i], merged['amount'][i]))

merged.plot(x='region', y='popCovered',figsize=(10,5),color='purple')

"""For each company as we have kind of 6 of them lets find out:
*   Number of wins
*   Total MOney Spend above reserved price
*   Average bids
*   Avg Winning bid over reserved 
*   Total population covered 
*   Overall population covered
*   Average population coved 
*   Regions

"""

dict_for_Overall_Data = {"owner":[], "population":[], "average_population":[], "total_spend":[], "average_spend":[], "average_spend_over_reserve":[]}

def Get_Insights(For_Winner):
    # Prepare Variables
    Number_of_Wins = 0
    Total_Spend = int(0)
    Average_Biding_Price = 0
    Average_Biding_Price_Over_Reserved = 0
    Population_Coverd = 0
    Average_Population_Covered = 0
    Regions = set()

    for index, row in merged.iterrows():
        if row['winner'] == For_Winner:
            Number_of_Wins += 1
            Total_Spend += row['headlinePriceLocal']
            Average_Biding_Price_Over_Reserved +=  row['headlinePriceLocal'] -  row['reservePriceLocal']
            Population_Coverd += row['popCovered']
            Regions.add(row['region'])
    

    Average_Biding_Price = Total_Spend / Number_of_Wins
    Average_Biding_Price_Over_Reserved /= Number_of_Wins
    Average_Population_Covered = Population_Coverd / Number_of_Wins

    print(For_Winner)
    print("Won in ", Number_of_Wins, "  Bids") 
    print("Total Spend : ",Total_Spend)
    print("Average Bidding Price : ", round(Average_Biding_Price, 2))
    print("Average Bidding prie over Reserved : ", round(Average_Biding_Price_Over_Reserved, 2))
    print("Total population Coverd : ", Population_Coverd)
    dict_for_Overall_Data["owner"].append(For_Winner)
    dict_for_Overall_Data["population"].append(Population_Coverd)
    dict_for_Overall_Data["average_population"].append(round(Average_Population_Covered, 2))
    dict_for_Overall_Data["total_spend"].append(Total_Spend)
    dict_for_Overall_Data["average_spend"].append(round(Average_Biding_Price, 2))
    dict_for_Overall_Data["average_spend_over_reserve"].append(round(Average_Biding_Price_Over_Reserved, 2))
    print("Average Population Coverd : ", round(Average_Population_Covered, 2))
    print("Regions Coverd are : ", Regions)
    print("-----------------------------------------------------------------------------------------------------")
    #return dict_for_Population_Overall

# dict_for_Population_Overall = {"owner":[],"population":[]}
for winner in merged['winner'].unique():
    Get_Insights(winner)
    print("")

print(dict_for_Overall_Data)

"""### Plots

"""

# Plot of Average population of each owner  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_population']
ax.bar(langs,students,color='red')
plt.xlabel('Winner')
plt.ylabel('Average Population')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# Plot of Total population of each owner
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['population']
ax.bar(langs,students)
plt.xlabel('Winner')
plt.ylabel('Population')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# Plot of total spending of each owner
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['total_spend']
ax.bar(langs,students,color='green')
plt.xlabel('Winner')
plt.ylabel('Total Spend')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# plot of average spending of each ownerr  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_spend']
ax.bar(langs,students,color='grey')
plt.xlabel('Winner')
plt.ylabel('Average Spend')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# plot of average spending over reserve  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_spend_over_reserve']
ax.bar(langs,students,color='orange')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.xlabel('Winner')
plt.ylabel('Average Spend above Reserve')
plt.show()

"""### Making dataframe compatible"""

# Make a copy to save preds for next year
Data_3G_next_year_preds = merged.copy()

# Model
# Remove column name 
merged.drop(['minAmount', 'amount'], axis = 1)

"""### Handle Null Values

"""

# Handle Nulls
merged_cols = merged.columns.to_list()
mv = merged[merged_cols].isnull().sum()
mp = mv / len(merged)*100
mp

# Drop columns with null values 
# These columns have null value throughout
merged = merged.drop(['lotComments', 'awardComments'], axis = 1)

# Delete columns which have only one or null values overall
for col in merged.columns.to_list():
    count = merged[col].nunique()
    if count == 1:
        del merged[col]
        print(col)
merged

'''
# Label Encoding
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import OneHotEncoder

merged['lotName'] = LabelEncoder().fit_transform(merged.lotName)
merged['winner'] = LabelEncoder().fit_transform(merged.winner)
merged['region'] = LabelEncoder().fit_transform(merged.region)
merged['blockFreq'] = LabelEncoder().fit_transform(merged.blockFreq)

merged
# One Hot Encoding
ohc = OneHotEncoder()
ohe = ohc.fit_transform(merged.winner.value.reshape(-1, 1)).to_array()
mergedOHE = pd.Dataframe(ohe, columns = ["Winner_" +str(ohc.categories[0][i])
                                                    for i in range(len(ohc.categories_[0]))])
mergedOHE = pd.concat([merged, mergedOHE], axis = 1)
merged
'''

"""### Frequency Encoding"""

# Frequency Encoding
def Frequency_Encode(col):
    # print(col)
    fe = merged.groupby(col).size() / len(merged)
    merged.loc[:, col + '_freq_encode'] = merged[col].map(fe)
    merged

for col in merged.columns.to_list():
    # print(col, type(merged[col]))
    if merged[col].dtype == 'object':
        Frequency_Encode(col)
        del merged[col]

merged

x = merged.copy()
del x['amount']
del x['minAmount']
# del x['headlinePriceLocal']
y = pd.DataFrame(merged.headlinePriceLocal)
x

y

print(x.shape, y.shape)

# Generating Next year Expected Prices
x_test = merged.copy()
x_test['reservePriceLocal'] = x_test['headlinePriceLocal']
del x_test['amount']
del x_test['minAmount']
# del x['headlinePriceLocal']
y_test = pd.DataFrame(merged.headlinePriceLocal)
x_test

"""### Correlarion Matrix"""

# Compute the correlation matrix
corr = x.corr()

# Generate a mask for the upper triangle
mask = np.zeros_like(corr, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(15, 9))

# Generate a custom diverging colormap
cmap = sns.diverging_palette(220, 10, as_cmap=True)

# Draw the heatmap with the mask and correct aspect ratio
sns.heatmap(corr, mask=mask, cmap=cmap, center=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5}, annot=True)

"""### Model"""

# x has train
# y has target var
del x['headlinePriceLocal']

train_dataset = cb.Pool(x, y)
model = cb.CatBoostRegressor(loss_function='RMSE')
grid = {'iterations': [150, 200, 300],
        'learning_rate': [0.1],
        'depth': [8, 10, 15],
        'l2_leaf_reg': [3, 5]}
model.grid_search(grid, train_dataset)

pred = model.predict(x)
rmse = (np.sqrt(mean_squared_error(y, pred)))
r2 = r2_score(y, pred)
print('Testing performance')
print('RMSE: {:.2f}'.format(rmse))
print('R2: {:.2f}'.format(r2))

# Take predictions on test datase
del x_test['headlinePriceLocal']
test_pred = model.predict(x_test)
rmse_test = (np.sqrt(mean_squared_error(x_test['reservePriceLocal'], test_pred)))
r2_test = r2_score(y, test_pred)
print('Testing performance')
print('RMSE: {:.2f}'.format(rmse_test))
print('R2: {:.2f}'.format(r2_test))
test_pred

sorted_feature_importance = model.feature_importances_.argsort()
'''
print(type(sorted_feature_importance))
print(type(merged))
print(type(x))
print(type(y))

df = pd.DataFrame(merged.data,columns=merged.feature_names)
df['target'] = pd.Series(merged.headlinePriceLocal)
'''

plt.barh(merged.columns[sorted_feature_importance], 
        model.feature_importances_[sorted_feature_importance], 
        color='tan')
plt.xlabel("CatBoost Feature Importance")

explainer = shap.TreeExplainer(model)
shap_values = explainer.shap_values(x)
shap.summary_plot(shap_values, x, feature_names = merged.columns[sorted_feature_importance])

# ITs right time to save the preds
Data_3G_next_year_preds

Data_3G_next_year_preds['reservePriceLocal'] = Data_3G_next_year_preds['headlinePriceLocal']
Data_3G_next_year_preds['minAmount'] = Data_3G_next_year_preds['headlinePriceLocal']
Data_3G_next_year_preds

Data_3G_next_year_preds['headlinePriceLocal'] = test_pred
Data_3G_next_year_preds['amount'] = test_pred

Data_3G_next_year_preds

Data_3G_next_year_preds['date'] = Data_3G_next_year_preds['date'].apply(lambda x: '2011-05-19')  
Data_3G_next_year_preds

Data_3G_next_year_preds.to_csv('Spectrum_Data_India_3G_next_year_preds.csv', index=False)

from google.colab import files
files.download("Spectrum_Data_India_3G_next_year_preds.csv")

"""# India 4G"""

merged = df_4G

merged

merged['awardName'].unique()

from matplotlib import pyplot as plt
plt.figure(figsize=(15,5))
# X axis : lotID
# Y axis : amount
plt.scatter(merged['lotId'], merged['headlinePriceLocal'])

#for i, winner in enumerate(merged['winner']):
#  plt.annotate(winner, (merged['lotId'][i], merged['reservePriceLocal'][i]))

merged.plot(x='region', y='popCovered',figsize=(10,5),color='purple')

"""For each company as we have kind of 6 of them lets find out:
*   Number of wins
*   Total MOney Spend above reserved price
*   Average bids
*   Avg Winning bid over reserved 
*   Total population covered 
*   Overall population covered
*   Average population coved 
*   Regions

"""

dict_for_Overall_Data = {"owner":[], "population":[], "average_population":[], "total_spend":[], "average_spend":[], "average_spend_over_reserve":[]}

def Get_Insights(For_Winner):
    # Prepare Variables
    Number_of_Wins = 0
    Total_Spend = int(0)
    Average_Biding_Price = 0
    Average_Biding_Price_Over_Reserved = 0
    Population_Coverd = 0
    Average_Population_Covered = 0
    Regions = set()

    for index, row in merged.iterrows():
        if row['winner'] == For_Winner:
            Number_of_Wins += 1
            Total_Spend += row['headlinePriceLocal']
            Average_Biding_Price_Over_Reserved +=  row['headlinePriceLocal'] -  row['reservePriceLocal']
            Population_Coverd += row['popCovered']
            Regions.add(row['region'])
    

    Average_Biding_Price = Total_Spend / Number_of_Wins
    Average_Biding_Price_Over_Reserved /= Number_of_Wins
    Average_Population_Covered = Population_Coverd / Number_of_Wins

    print(For_Winner)
    print("Won in ", Number_of_Wins, "  Bids") 
    print("Total Spend : ",Total_Spend)
    print("Average Bidding Price : ", round(Average_Biding_Price, 2))
    print("Average Bidding prie over Reserved : ", round(Average_Biding_Price_Over_Reserved, 2))
    print("Total population Coverd : ", Population_Coverd)
    dict_for_Overall_Data["owner"].append(For_Winner)
    dict_for_Overall_Data["population"].append(Population_Coverd)
    dict_for_Overall_Data["average_population"].append(round(Average_Population_Covered, 2))
    dict_for_Overall_Data["total_spend"].append(Total_Spend)
    dict_for_Overall_Data["average_spend"].append(round(Average_Biding_Price, 2))
    dict_for_Overall_Data["average_spend_over_reserve"].append(round(Average_Biding_Price_Over_Reserved, 2))
    print("Average Population Coverd : ", round(Average_Population_Covered, 2))
    print("Regions Coverd are : ", Regions)
    print("-----------------------------------------------------------------------------------------------------")
    #return dict_for_Population_Overall

# dict_for_Population_Overall = {"owner":[],"population":[]}
    
for winner in merged['winner'].unique():
    Get_Insights(winner)
    print("")

print(dict_for_Overall_Data)

"""### Plots"""

# Plot of Average population of each owner  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_population']
ax.bar(langs,students,color='red')
plt.xlabel('Winner')
plt.ylabel('Average Population')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# Plot of Total population of each owner
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['population']
ax.bar(langs,students)
plt.xlabel('Winner')
plt.ylabel('Population')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# Plot of total spending of each owner
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['total_spend']
ax.bar(langs,students,color='green')
plt.xlabel('Winner')
plt.ylabel('Total Spend')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# plot of average spending of each ownerr  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_spend']
ax.bar(langs,students,color='grey')
plt.xlabel('Winner')
plt.ylabel('Average Spend')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# plot of average spending over reserve  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_spend_over_reserve']
ax.bar(langs,students,color='orange')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.xlabel('Winner')
plt.ylabel('Average Spend above Reserve')
plt.show()

"""### Making dataframe compatible"""

# Model
# Remove column name 
# merged.drop(['headlinePriceLocal'], axis = 1)

# Make a copy to save preds for next year
Data_4G_next_year_preds = merged.copy()

"""### Handling Null VAlues"""

# Handle Nulls
merged_cols = merged.columns.to_list()
mv = merged[merged_cols].isnull().sum()
mp = mv / len(merged)*100
mp

# Drop columns with null values
merged = merged.drop(['lotComments', 'awardComments'], axis = 1)

# Delete columns which have only one or null values overall
for col in merged.columns.to_list():
    count = merged[col].nunique()
    if count == 1:
        del merged[col]
merged

'''
# Label Encoding
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import OneHotEncoder

merged['lotName'] = LabelEncoder().fit_transform(merged.lotName)
merged['winner'] = LabelEncoder().fit_transform(merged.winner)
merged['region'] = LabelEncoder().fit_transform(merged.region)
merged['blockFreq'] = LabelEncoder().fit_transform(merged.blockFreq)

merged
# One Hot Encoding
ohc = OneHotEncoder()
ohe = ohc.fit_transform(merged.winner.value.reshape(-1, 1)).to_array()
mergedOHE = pd.Dataframe(ohe, columns = ["Winner_" +str(ohc.categories[0][i])
                                                    for i in range(len(ohc.categories_[0]))])
mergedOHE = pd.concat([merged, mergedOHE], axis = 1)
merged
'''

t = merged.corr()
t

"""### Frequency Encoding"""

# Frequency Encoding
def Frequency_Encode(col):
    # print(col)
    fe = merged.groupby(col).size() / len(merged)
    merged.loc[:, col + '_freq_encode'] = merged[col].map(fe)
    merged

for col in merged.columns.to_list():
    # print(col, type(merged[col]))
    if merged[col].dtype == 'object':
        Frequency_Encode(col)
        del merged[col]

merged

x = merged.copy()
# del x['headlinePriceLocal']
y = pd.DataFrame(merged.headlinePriceLocal)
x

y

print(x.shape, y.shape)

# Generating Next year Expected Prices
x_test = merged.copy()
x_test['reservePriceLocal'] = x_test['headlinePriceLocal']

y_test = pd.DataFrame(merged.headlinePriceLocal)
x_test

"""### Correlation Matrix"""

# Compute the correlation matrix
corr = x.corr()

# Generate a mask for the upper triangle
mask = np.zeros_like(corr, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(11, 9))

# Generate a custom diverging colormap
cmap = sns.diverging_palette(220, 10, as_cmap=True)

# Draw the heatmap with the mask and correct aspect ratio
sns.heatmap(corr, mask=mask, cmap=cmap, center=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5}, annot=True)

"""### Model"""

# x has train
# y has target var
del x['headlinePriceLocal']

train_dataset = cb.Pool(x, y)
model = cb.CatBoostRegressor(loss_function='RMSE')
grid = {'iterations': [150, 200, 300],
        'learning_rate': [0.1],
        'depth': [8, 10, 15],
        'l2_leaf_reg': [3, 5]}
model.grid_search(grid, train_dataset)

# Predicting headline price (final bidding price) for India 4G for the year 2013
pred = model.predict(x) 
rmse = (np.sqrt(mean_squared_error(y, pred)))
r2 = r2_score(y, pred)
print('Testing performance')
print('RMSE: {:.2f}'.format(rmse))
print('R2: {:.2f}'.format(r2))

# Take predictions on test datase
del x_test['headlinePriceLocal']
test_pred = model.predict(x_test)
rmse_test = (np.sqrt(mean_squared_error(x_test['reservePriceLocal'], test_pred)))
r2_test = r2_score(y, test_pred)
print('Testing performance')
print('RMSE: {:.2f}'.format(rmse_test))
print('R2: {:.2f}'.format(r2_test))
test_pred

sorted_feature_importance = model.feature_importances_.argsort()
'''
print(type(sorted_feature_importance))
print(type(merged))
print(type(x))
print(type(y))

df = pd.DataFrame(merged.data,columns=merged.feature_names)
df['target'] = pd.Series(merged.headlinePriceLocal)
'''

plt.barh(merged.columns[sorted_feature_importance], 
        model.feature_importances_[sorted_feature_importance], 
        color='lightcoral')
plt.xlabel("CatBoost Feature Importance")

explainer = shap.TreeExplainer(model)
shap_values = explainer.shap_values(x)
shap.summary_plot(shap_values, x, feature_names = merged.columns[sorted_feature_importance])



# ITs right time to save the preds
Data_4G_next_year_preds

Data_4G_next_year_preds['reservePriceLocal'] = Data_4G_next_year_preds['headlinePriceLocal']
Data_4G_next_year_preds['minAmount'] = Data_4G_next_year_preds['headlinePriceLocal']
Data_4G_next_year_preds

Data_4G_next_year_preds['headlinePriceLocal'] = test_pred
Data_4G_next_year_preds['amount'] = test_pred

Data_4G_next_year_preds

# Data_4G_next_year_preds['date'] = Data_4G_next_year_preds['date'].apply(lambda x: '2011-05-19')  
# Data_4G_next_year_preds

Data_4G_next_year_preds.to_csv('Spectrum_Data_India_4G_next_year_preds.csv', index=False)

from google.colab import files
files.download("Spectrum_Data_India_4G_next_year_preds.csv")



"""# India 2G"""

merged = df_2G

merged

merged['awardName'].unique()

from matplotlib import pyplot as plt
plt.figure(figsize=(15,5))
# X axis : lotID
# Y axis : amount
plt.scatter(merged['lotId'], merged['headlinePriceLocal'])

#for i, winner in enumerate(merged['winner']):
#    plt.annotate(winner, (merged['lotId'][i], merged['headlinePriceLocal'][i]))

merged.plot(x='region', y='popCovered',figsize=(10,5),color='purple')

"""For each company as we have kind of 6 of them lets find out:
*   Number of wins
*   Total MOney Spend above reserved price
*   Average bids
*   Avg Winning bid over reserved 
*   Total population covered 
*   Overall population covered
*   Average population coved 
*   Regions

"""

dict_for_Overall_Data = {"owner":[], "population":[], "average_population":[], "total_spend":[], "average_spend":[], "average_spend_over_reserve":[]}

def Get_Insights(For_Winner):
    # Prepare Variables
    Number_of_Wins = 0
    Total_Spend = int(0)
    Average_Biding_Price = 0
    Average_Biding_Price_Over_Reserved = 0
    Population_Coverd = 0
    Average_Population_Covered = 0
    Regions = set()

    for index, row in merged.iterrows():
        if row['winner'] == For_Winner:
            Number_of_Wins += 1
            Total_Spend += row['headlinePriceLocal']
            Average_Biding_Price_Over_Reserved +=  row['headlinePriceLocal'] -  row['reservePriceLocal']
            Population_Coverd += row['popCovered']
            Regions.add(row['region'])
    

    Average_Biding_Price = Total_Spend / Number_of_Wins
    Average_Biding_Price_Over_Reserved /= Number_of_Wins
    Average_Population_Covered = Population_Coverd / Number_of_Wins

    print(For_Winner)
    print("Won in ", Number_of_Wins, "  Bids") 
    print("Total Spend : ",Total_Spend)
    print("Average Bidding Price : ", round(Average_Biding_Price, 2))
    print("Average Bidding prie over Reserved : ", round(Average_Biding_Price_Over_Reserved, 2))
    print("Total population Coverd : ", Population_Coverd)
    dict_for_Overall_Data["owner"].append(For_Winner)
    dict_for_Overall_Data["population"].append(Population_Coverd)
    dict_for_Overall_Data["average_population"].append(round(Average_Population_Covered, 2))
    dict_for_Overall_Data["total_spend"].append(Total_Spend)
    dict_for_Overall_Data["average_spend"].append(round(Average_Biding_Price, 2))
    dict_for_Overall_Data["average_spend_over_reserve"].append(round(Average_Biding_Price_Over_Reserved, 2))
    print("Average Population Coverd : ", round(Average_Population_Covered, 2))
    print("Regions Coverd are : ", Regions)
    print("-----------------------------------------------------------------------------------------------------")
    #return dict_for_Population_Overall

# dict_for_Population_Overall = {"owner":[],"population":[]}
    
for winner in merged['winner'].unique():
    Get_Insights(winner)
    print("")

print(dict_for_Overall_Data)

"""### Plots"""

# Plot of Average population of each owner  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_population']
ax.bar(langs,students,color='red')
plt.xlabel('Winner')
plt.ylabel('Average Population')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# Plot of Total population of each owner
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['population']
ax.bar(langs,students)
plt.xlabel('Winner')
plt.ylabel('Population')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# Plot of total spending of each owner
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['total_spend']
ax.bar(langs,students,color='green')
plt.xlabel('Winner')
plt.ylabel('Total Spend')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# plot of average spending of each ownerr  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_spend']
ax.bar(langs,students,color='grey')
plt.xlabel('Winner')
plt.ylabel('Average Spend')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.show()

# plot of average spending over reserve  
fig = plt.figure(figsize=(12, 3))
ax = fig.add_axes([0,0,1,1])
langs = dict_for_Overall_Data['owner']
students = dict_for_Overall_Data['average_spend_over_reserve']
ax.bar(langs,students,color='orange')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
plt.xlabel('Winner')
plt.ylabel('Average Spend above Reserve')
plt.show()

"""### Making dataframe compatible"""

# Model
# Remove column name 
# merged.drop(['reservePriceLocal', 'headlinePriceLocal'], axis = 1)
# Make a copy to save preds for next year
Data_2G_next_year_preds = merged.copy()

"""### Handling Null Values"""

# Handle Nulls
merged_cols = merged.columns.to_list()
mv = merged[merged_cols].isnull().sum()
mp = mv / len(merged)*100
mp

# Drop columns with null values
merged = merged.drop(['lotComments', 'awardComments'], axis = 1)

# Delete columns which have only one or null values overall
for col in merged.columns.to_list():
    count = merged[col].nunique()
    if count == 1:
        del merged[col]
        print(col)
merged

'''
# Label Encoding
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import OneHotEncoder

merged['lotName'] = LabelEncoder().fit_transform(merged.lotName)
merged['winner'] = LabelEncoder().fit_transform(merged.winner)
merged['region'] = LabelEncoder().fit_transform(merged.region)
merged['blockFreq'] = LabelEncoder().fit_transform(merged.blockFreq)

merged
# One Hot Encoding
ohc = OneHotEncoder()
ohe = ohc.fit_transform(merged.winner.value.reshape(-1, 1)).to_array()
mergedOHE = pd.Dataframe(ohe, columns = ["Winner_" +str(ohc.categories[0][i])
                                                    for i in range(len(ohc.categories_[0]))])
mergedOHE = pd.concat([merged, mergedOHE], axis = 1)
merged
'''

t = merged.corr()
t

# Frequency Encoding
def Frequency_Encode(col):
    # print(col)
    fe = merged.groupby(col).size() / len(merged)
    merged.loc[:, col + '_freq_encode'] = merged[col].map(fe)
    merged

for col in merged.columns.to_list():
    # print(col, type(merged[col]))
    if merged[col].dtype == 'object':
        Frequency_Encode(col)
        del merged[col]

merged

x = merged.copy()
# del x['reservePriceLocal']
y = pd.DataFrame(merged.headlinePriceLocal)
x

y

print(x.shape, y.shape)



# Generating Next year Expected Prices
x_test = merged.copy()
x_test['reservePriceLocal'] = x_test['headlinePriceLocal']
# del x_test['amount']
# del x_test['minAmount']
# del x['headlinePriceLocal']
y_test = pd.DataFrame(merged.headlinePriceLocal)
x_test

"""### Correlation Matrix"""

# Compute the correlation matrix
corr = x.corr()

# Generate a mask for the upper triangle
mask = np.zeros_like(corr, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(11, 9))

# Generate a custom diverging colormap
cmap = sns.diverging_palette(220, 10, as_cmap=True)

# Draw the heatmap with the mask and correct aspect ratio
sns.heatmap(corr, mask=mask, cmap=cmap, center=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5}, annot=True)

"""### Model"""

## x has train
# y has target var
del x['headlinePriceLocal']

train_dataset = cb.Pool(x, y)
model = cb.CatBoostRegressor(loss_function='RMSE')
grid = {'iterations': [150, 200, 300],
        'learning_rate': [0.1],
        'depth': [8, 10, 15],
        'l2_leaf_reg': [3, 5]}
model.grid_search(grid, train_dataset)

pred = model.predict(x)
rmse = (np.sqrt(mean_squared_error(y, pred)))
r2 = r2_score(y, pred)
print('Testing performance')
print('RMSE: {:.2f}'.format(rmse))
print('R2: {:.2f}'.format(r2))



# Take predictions on test datase
del x_test['headlinePriceLocal']
test_pred = model.predict(x_test)
rmse_test = (np.sqrt(mean_squared_error(x_test['reservePriceLocal'], test_pred)))
r2_test = r2_score(y, test_pred)
print('Testing performance')
print('RMSE: {:.2f}'.format(rmse_test))
print('R2: {:.2f}'.format(r2_test))
test_pred

sorted_feature_importance = model.feature_importances_.argsort()
'''
print(type(sorted_feature_importance))
print(type(merged))
print(type(x))
print(type(y))

df = pd.DataFrame(merged.data,columns=merged.feature_names)
df['target'] = pd.Series(merged.headlinePriceLocal)
'''

plt.barh(merged.columns[sorted_feature_importance], 
        model.feature_importances_[sorted_feature_importance], 
        color='olivedrab')
plt.xlabel("CatBoost Feature Importance")

explainer = shap.TreeExplainer(model)
shap_values = explainer.shap_values(x)
shap.summary_plot(shap_values, x, feature_names = merged.columns[sorted_feature_importance])



# ITs right time to save the preds
Data_2G_next_year_preds

Data_2G_next_year_preds['reservePriceLocal'] = Data_2G_next_year_preds['headlinePriceLocal']
Data_2G_next_year_preds['minAmount'] = Data_2G_next_year_preds['headlinePriceLocal']
Data_2G_next_year_preds

Data_2G_next_year_preds['headlinePriceLocal'] = test_pred
Data_2G_next_year_preds['amount'] = test_pred

Data_2G_next_year_preds

Data_2G_next_year_preds['date'] = Data_2G_next_year_preds['date'].apply(lambda x: '2013-11-14')  
Data_2G_next_year_preds

Data_2G_next_year_preds.to_csv('Spectrum_Data_India_2G_next_year_preds.csv', index=False)

from google.colab import files
files.download("Spectrum_Data_India_2G_next_year_preds.csv")